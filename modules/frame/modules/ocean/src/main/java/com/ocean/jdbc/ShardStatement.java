package com.ocean.jdbc;

import com.google.common.hash.HashCode;
import com.google.common.hash.Hashing;
import com.ocean.executor.StatementExecutor;
import com.ocean.jdbc.adapter.AbstractStatementAdapter;
import com.ocean.merger.MergeContext;
import com.ocean.merger.resultset.ResultSetFactory;
import com.ocean.router.SqlExecutionUnit;
import com.ocean.router.SqlRouteEngine;
import com.ocean.router.SqlRouteResult;
import org.apache.commons.codec.Charsets;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

/**
 * 支持分片的静态语句对象
 */
public class ShardStatement extends AbstractStatementAdapter {

    private ShardConnection shardConnection;

    private SqlRouteEngine sqlRouteEngine;

    private int resultSetType;

    private int resultSetConcurrency;

    private int resultSetHoldability;

    private Map<HashCode, Statement> cachedRoutedStatements = new HashMap<HashCode, Statement>();

    private ResultSet currentResultSet;

    private MergeContext mergeContext;

    public ShardStatement(SqlRouteEngine sqlRouteEngine, ShardConnection shardConnection) throws SQLException {
        this(sqlRouteEngine, shardConnection, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardStatement(SqlRouteEngine sqlRouteEngine, ShardConnection shardConnection, int resultSetType, int resultSetConcurrency) throws SQLException {
        this(sqlRouteEngine, shardConnection, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardStatement(SqlRouteEngine sqlRouteEngine, ShardConnection shardConnection,
                             int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        this.shardConnection = shardConnection;
        this.sqlRouteEngine = sqlRouteEngine;
        this.resultSetType = resultSetType;
        this.resultSetConcurrency = resultSetConcurrency;
        this.resultSetHoldability = resultSetHoldability;
    }

    public ShardConnection getShardConnection() {
        return shardConnection;
    }

    public void setShardConnection(ShardConnection shardConnection) {
        this.shardConnection = shardConnection;
    }

    public SqlRouteEngine getSqlRouteEngine() {
        return sqlRouteEngine;
    }

    public void setSqlRouteEngine(SqlRouteEngine sqlRouteEngine) {
        this.sqlRouteEngine = sqlRouteEngine;
    }

    public int getResultSetType() {
        return resultSetType;
    }

    public void setResultSetType(int resultSetType) {
        this.resultSetType = resultSetType;
    }

    public int getResultSetConcurrency() {
        return resultSetConcurrency;
    }

    public void setResultSetConcurrency(int resultSetConcurrency) {
        this.resultSetConcurrency = resultSetConcurrency;
    }

    public int getResultSetHoldability() {
        return resultSetHoldability;
    }

    public void setResultSetHoldability(int resultSetHoldability) {
        this.resultSetHoldability = resultSetHoldability;
    }

    public Map<HashCode, Statement> getCachedRoutedStatements() {
        return cachedRoutedStatements;
    }

    public void setCachedRoutedStatements(Map<HashCode, Statement> cachedRoutedStatements) {
        this.cachedRoutedStatements = cachedRoutedStatements;
    }

    public ResultSet getCurrentResultSet() {
        return currentResultSet;
    }

    public void setCurrentResultSet(ResultSet currentResultSet) {
        this.currentResultSet = currentResultSet;
    }

    public MergeContext getMergeContext() {
        return mergeContext;
    }

    public void setMergeContext(MergeContext mergeContext) {
        this.mergeContext = mergeContext;
    }

    @Override
    public Connection getConnection() throws SQLException {
        return shardConnection;
    }

    @Override
    public ResultSet executeQuery(final String sql) throws SQLException {
        if (null != currentResultSet && !currentResultSet.isClosed()) {
            currentResultSet.close();
        }
        currentResultSet = ResultSetFactory.getResultSet(generateExecutor(sql).executeQuery(), mergeContext);
        return currentResultSet;
    }

    @Override
    public int executeUpdate(final String sql) throws SQLException {
        return generateExecutor(sql).executeUpdate();
    }

    @Override
    public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
        return generateExecutor(sql).executeUpdate(autoGeneratedKeys);
    }

    @Override
    public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
        return generateExecutor(sql).executeUpdate(columnIndexes);
    }

    @Override
    public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
        return generateExecutor(sql).executeUpdate(columnNames);
    }

    @Override
    public boolean execute(final String sql) throws SQLException {
        return generateExecutor(sql).execute();
    }

    @Override
    public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
        return generateExecutor(sql).execute(autoGeneratedKeys);
    }

    @Override
    public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
        return generateExecutor(sql).execute(columnIndexes);
    }

    @Override
    public boolean execute(final String sql, final String[] columnNames) throws SQLException {
        return generateExecutor(sql).execute(columnNames);
    }

    private StatementExecutor generateExecutor(final String sql) throws SQLException {
        StatementExecutor result = new StatementExecutor();
        SqlRouteResult sqlRouteResult = sqlRouteEngine.route(sql, Collections.emptyList());
        mergeContext = sqlRouteResult.getMergeContext();
        for (SqlExecutionUnit each : sqlRouteResult.getExecutionUnits()) {
            result.addStatement(each.getSql(), generateStatement(each.getSql(), each.getDataSource()));
        }
        return result;
    }

    private Statement generateStatement(final String sql, final String dataSourceName) throws SQLException {
        HashCode hashCode =  Hashing.md5().newHasher().putString(sql, Charsets.UTF_8).putString(dataSourceName, Charsets.UTF_8).hash();
        if (cachedRoutedStatements.containsKey(hashCode)) {
            return cachedRoutedStatements.get(hashCode);
        }
        Connection connection = shardConnection.getConnection(dataSourceName);
        Statement result;
        if (0 == resultSetHoldability) {
            result = connection.createStatement(resultSetType, resultSetConcurrency);
        } else {
            result = connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
        }
        doMethodsInvovation(result);
        cachedRoutedStatements.put(hashCode, result);
        return result;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        if (null != currentResultSet) {
            return currentResultSet;
        }
        List<ResultSet> resultSets = new ArrayList<ResultSet>(getRoutedStatements().size());
        for (Statement each : getRoutedStatements()) {
            resultSets.add(each.getResultSet());
        }
        currentResultSet = ResultSetFactory.getResultSet(resultSets, mergeContext);
        return currentResultSet;
    }

    @Override
    public Collection<? extends Statement> getRoutedStatements() throws SQLException {
        return cachedRoutedStatements.values();
    }
}