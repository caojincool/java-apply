package com.ocean.jdbc;

import com.google.common.collect.Lists;
import com.google.common.hash.HashCode;
import com.ocean.executor.PreparedStatementExecutor;
import com.ocean.jdbc.adapter.AbstractPreparedStatementAdapter;
import com.ocean.jdbc.adapter.AbstractStatementAdapter;
import com.ocean.merger.resultset.ResultSetFactory;
import com.ocean.router.SqlExecutionUnit;
import com.ocean.router.SqlRouteEngine;
import com.ocean.router.SqlRouteResult;

import java.sql.*;
import java.util.*;

/**
 * 支持分片的预编译语句对象
 */
public class ShardPreparedStatement extends AbstractPreparedStatementAdapter {

    private String sql;

    private Collection<PreparedStatement> cachedRoutedPreparedStatements = new LinkedList<PreparedStatement>();

    private Integer autoGeneratedKeys;

    private int[] columnIndexes;

    private String[] columnNames;

    private boolean hasExecuted;

    private SqlRouteEngine sqlRouteEngine;

    private List<List<Object>> batchParameters = new ArrayList<List<Object>>();

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection,
                                     String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection,
                                     String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        super(SqlRouteEngine, shardConnection, resultSetType, resultSetConcurrency, resultSetHoldability);
        this.sql = sql;
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql, int autoGeneratedKeys) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql);
        this.autoGeneratedKeys = autoGeneratedKeys;
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql, int[] columnIndexes) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql);
        this.columnIndexes = columnIndexes;
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql, String[] columnNames) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql);
        this.columnNames = columnNames;
    }

    public SqlRouteEngine getSqlRouteEngine() {
        return sqlRouteEngine;
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        hasExecuted = true;
        setCurrentResultSet(ResultSetFactory.getResultSet(new PreparedStatementExecutor(getRoutedPreparedStatements()).executeQuery(), getMergeContext()));
        return getCurrentResultSet();
    }

    @Override
    public int executeUpdate() throws SQLException {
        hasExecuted = true;
        return new PreparedStatementExecutor(getRoutedPreparedStatements()).executeUpdate();
    }

    @Override
    public boolean execute() throws SQLException {
        hasExecuted = true;
        return new PreparedStatementExecutor(getRoutedPreparedStatements()).execute();
    }

    @Override
    public void addBatch() throws SQLException {
        batchParameters.add(Lists.newArrayList(getParameters()));
        getParameters().clear();
    }

    @Override
    public void clearBatch() throws SQLException {
        batchParameters.clear();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        hasExecuted = true;
        int[] result = new int[batchParameters.size()];
        int i = 0;
        for (List<Object> each : batchParameters) {
            result[i++] = new PreparedStatementExecutor(routeSQL(each)).executeUpdate();
        }
        return result;
    }

    private Collection<PreparedStatement> getRoutedPreparedStatements() throws SQLException {
        if (!hasExecuted) {
            return Collections.emptyList();
        }
        routeIfNeed();
        return cachedRoutedPreparedStatements;
    }

    @Override
    public Collection<? extends Statement> getRoutedStatements() throws SQLException {
        return getRoutedPreparedStatements();
    }

    private void routeIfNeed() throws SQLException {
        if (!cachedRoutedPreparedStatements.isEmpty()) {
            return;
        }
        cachedRoutedPreparedStatements.addAll(routeSQL(getParameters()));
    }

    private List<PreparedStatement> routeSQL(List<Object> parameters) throws SQLException {
        List<PreparedStatement> result = new ArrayList<PreparedStatement>();
        SqlRouteResult sqlRouteResult = getSqlRouteEngine().route(sql, parameters);
        setMergeContext(sqlRouteResult.getMergeContext());
        for (SqlExecutionUnit each : sqlRouteResult.getExecutionUnits()) {
            PreparedStatement preparedStatement = generatePrepareStatement(getShardConnection().getConnection(each.getDataSource()), each.getSql());
            doMethodsInvovation(preparedStatement);
            setParameters(preparedStatement, parameters);
            result.add(preparedStatement);
        }
        return result;
    }

    private PreparedStatement generatePrepareStatement(Connection conn, String shardingSql) throws SQLException {
        if (null != autoGeneratedKeys) {
            return conn.prepareStatement(shardingSql, autoGeneratedKeys);
        }
        if (null != columnIndexes) {
            return conn.prepareStatement(shardingSql, columnIndexes);
        }
        if (null != columnNames) {
            return conn.prepareStatement(shardingSql, columnNames);
        }
        if (0 != getResultSetHoldability()) {
            return conn.prepareStatement(shardingSql, getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());
        }
        return conn.prepareStatement(shardingSql, getResultSetType(), getResultSetConcurrency());
    }

    private void setParameters(PreparedStatement preparedStatement, List<Object> parameters) throws SQLException {
        int i = 1;
        for (Object each : parameters) {
            preparedStatement.setObject(i++, each);
        }
    }
}
