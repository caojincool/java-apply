package com.ocean.jdbc;

import com.google.common.collect.Lists;
import com.ocean.executor.PreparedStatementExecutor;
import com.ocean.jdbc.adapter.AbstractPreparedStatementAdapter;
import com.ocean.merger.resultset.ResultSetFactory;
import com.ocean.router.SqlExecutionUnit;
import com.ocean.router.SqlRouteEngine;
import com.ocean.router.SqlRouteResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.*;

/**
 * 支持分片的预编译语句对象
 */
public class ShardPreparedStatement extends AbstractPreparedStatementAdapter {

    private static Logger logger = LoggerFactory.getLogger(ShardPreparedStatement.class);

    private String sql;

    //实际上是PreparedStatement
    private Collection<PreparedStatement> cachedRoutedPreparedStatements = new LinkedList<PreparedStatement>();

    private Integer autoGeneratedKeys;

    private int[] columnIndexes;

    private String[] columnNames;

    private boolean hasExecuted;

    private List<List<Object>> batchParameters = new ArrayList<List<Object>>();

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql) throws SQLException {

        //参数resultSetType
        //ResultSet.TYPE_FORWORD_ONLY 结果集的游标只能向下滚动
        //ResultSet.TYPE_SCROLL_INSENSITIVE 结果集的游标可以上下移动，当数据库变化时，当前结果集不变
        //ResultSet.TYPE_SCROLL_SENSITIVE 返回可滚动的结果集，当数据库变化时，当前结果集同步改变

        //参数resultSetConcurrency
        //ResultSet.CONCUR_READ_ONLY 只读,不能用结果集更新数据库中的表。
        //ResultSet.CONCUR_UPDATETABLE 能用结果集更新数据库中的表。

        //参数resultSetHoldability
        //ResultSet.HOLD_CURSORS_OVER_COMMIT 表示修改提交时ResultSet不关闭 JDBC3.0即以上才支持
        //ResultSet.CLOSE_CURSORS_AT_COMMIT  表示修改提交时ResultSet关闭

        this(SqlRouteEngine, shardConnection, sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection,
                                     String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection,
                                     String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        super(SqlRouteEngine, shardConnection, resultSetType, resultSetConcurrency, resultSetHoldability);
        this.sql = sql;
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql, int autoGeneratedKeys) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql);
        this.autoGeneratedKeys = autoGeneratedKeys;
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql, int[] columnIndexes) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql);
        this.columnIndexes = columnIndexes;
    }

    public ShardPreparedStatement(SqlRouteEngine SqlRouteEngine, ShardConnection shardConnection, String sql, String[] columnNames) throws SQLException {
        this(SqlRouteEngine, shardConnection, sql);
        this.columnNames = columnNames;
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        logger.info("ShardPreparedStatement executeQuery");
        hasExecuted = true;
        List<ResultSet> list =new PreparedStatementExecutor(getRoutedPreparedStatements()).executeQuery();
        if(getMergeContext()==null)
        {
            logger.info("ShardPreparedStatement mergeContext is null");
        }
        ResultSet rs =ResultSetFactory.getResultSet(list,getMergeContext());
        setCurrentResultSet(rs);
        return getCurrentResultSet();
    }

    @Override
    public int executeUpdate() throws SQLException {
        logger.info("ShardPreparedStatement executeUpdate");
        hasExecuted = true;
        return new PreparedStatementExecutor(getRoutedPreparedStatements()).executeUpdate();
    }

    @Override
    public boolean execute() throws SQLException {
        logger.info("ShardPreparedStatement execute");
        hasExecuted = true;
        return new PreparedStatementExecutor(getRoutedPreparedStatements()).execute();
    }

    @Override
    public void addBatch() throws SQLException {
        batchParameters.add(Lists.newArrayList(getParameters()));
        getParameters().clear();
    }

    @Override
    public void clearBatch() throws SQLException {
        batchParameters.clear();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        logger.info("ShardPreparedStatement executeBatch");
        hasExecuted = true;
        int[] result = new int[batchParameters.size()];
        int i = 0;
        for (List<Object> each : batchParameters) {
            result[i++] = new PreparedStatementExecutor(routeSQL(each)).executeUpdate();
        }
        return result;
    }

    private Collection<PreparedStatement> getRoutedPreparedStatements() throws SQLException {
        if (!hasExecuted) {
            return Collections.emptyList();
        }
        routeIfNeed();
        return cachedRoutedPreparedStatements;
    }

    @Override
    public Collection<? extends Statement> getRoutedStatements() throws SQLException {
        return getRoutedPreparedStatements();
    }

    private void routeIfNeed() throws SQLException {
        if (!cachedRoutedPreparedStatements.isEmpty()) {
            return;
        }
        cachedRoutedPreparedStatements.addAll(routeSQL(getParameters()));
    }

    private List<PreparedStatement> routeSQL(List<Object> parameters) throws SQLException {

        logger.info("----------------ShardPreparedStatement routeSQL start-----------------");
        List<PreparedStatement> result = new ArrayList<PreparedStatement>();
        SqlRouteResult sqlRouteResult = getSqlRouteEngine().route(sql, parameters);
        logger.info("ShardPreparedStatement routeSQL 给ShardPreparedStatement设置mergeContext,其值为sqlRouteResult的mergeContext");
        setMergeContext(sqlRouteResult.getMergeContext());
        for (SqlExecutionUnit each : sqlRouteResult.getExecutionUnits()) {

            //对每个单元生成preparedStatement
            PreparedStatement preparedStatement = generatePrepareStatement(getShardConnection().getConnection(each.getDataSource()), each.getSql());
            doMethodsInvovation(preparedStatement);

            //设置条件参数
            setParameters(preparedStatement, parameters);
            result.add(preparedStatement);
        }
        logger.info("---------------ShardPreparedStatement routeSQL end------------------");
        return result;
    }

    private PreparedStatement generatePrepareStatement(Connection conn, String shardingSql) throws SQLException {

        logger.info("ShardPreparedStatement generatePrepareStatement shardingSql="+shardingSql);

        if (null != autoGeneratedKeys) {
            return conn.prepareStatement(shardingSql, autoGeneratedKeys);
        }
        if (null != columnIndexes) {
            return conn.prepareStatement(shardingSql, columnIndexes);
        }
        if (null != columnNames) {
            return conn.prepareStatement(shardingSql, columnNames);
        }
        if (0 != getResultSetHoldability()) {
            return conn.prepareStatement(shardingSql, getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());
        }
        return conn.prepareStatement(shardingSql, getResultSetType(), getResultSetConcurrency());
    }

    private void setParameters(PreparedStatement preparedStatement, List<Object> parameters) throws SQLException {
        int i = 1;
        for (Object each : parameters) {
            preparedStatement.setObject(i++, each);
        }
    }
}
