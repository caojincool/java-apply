package com.ocean.jdbc;

import com.ocean.shard.rule.ShardRule;
import com.ocean.jdbc.adapter.AbstractConnectionAdapter;
import com.ocean.router.SqlRouteEngine;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

/**
 * 分片连接
 */
public class ShardConnection extends AbstractConnectionAdapter {

    private static Logger logger = LoggerFactory.getLogger(ShardConnection.class);

    private ShardRule shardRule;

    private DatabaseMetaData metaData;

    private Map<String, Connection> connectionMap = new HashMap<String, Connection>();

    private SqlRouteEngine sqlRouteEngine;

    public ShardConnection(ShardRule shardRule, DatabaseMetaData metaData) throws SQLException {
        this.shardRule = shardRule;
        this.metaData = metaData;
        sqlRouteEngine = new SqlRouteEngine(shardRule, DatabaseType.valueFrom(metaData.getDatabaseProductName()));
        System.out.println("ShardConnection create sqlRouteEngine");
    }

    /**
     * 根据数据源名称获取相应的数据库连接
     * @param dataSourceName 数据源名称
     * @return 数据库连接
     */
    public Connection getConnection(String dataSourceName) throws SQLException {
        if (connectionMap.containsKey(dataSourceName)) {
            return connectionMap.get(dataSourceName);
        }

        Connection connection = shardRule.getDataSourceRule().getDataSourceMap().get(dataSourceName).getConnection();

        doMethodsInvovation(connection);
        connectionMap.put(dataSourceName, connection);
        return connection;
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        return metaData;
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {

        logger.info("ShardConnection prepareStatement invoke,sql="+sql);
        return new ShardPreparedStatement(sqlRouteEngine, this, sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return new ShardPreparedStatement(sqlRouteEngine, this, sql, resultSetType, resultSetConcurrency);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return new ShardPreparedStatement(sqlRouteEngine, this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return new ShardPreparedStatement(sqlRouteEngine, this, sql, autoGeneratedKeys);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return new ShardPreparedStatement(sqlRouteEngine, this, sql, columnIndexes);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return new ShardPreparedStatement(sqlRouteEngine, this, sql, columnNames);
    }

    @Override
    public Statement createStatement() throws SQLException {
        logger.info("ShardConnection createStatement invoke..");
        return new ShardStatement(sqlRouteEngine, this);
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return new ShardStatement(sqlRouteEngine, this, resultSetType, resultSetConcurrency);
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return new ShardStatement(sqlRouteEngine, this, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public Collection<Connection> getConnections() {
        return connectionMap.values();
    }
}
