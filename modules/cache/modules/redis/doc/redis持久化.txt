----------------------------------redis持久化------------------------------------
RDB---RDB持久化可以在指定的时间间隔内生成数据集的时间点快照(point-in-time snapshot)。
      RDB是一种表示某个即时点的 Redis 数据的紧凑文件。
      RDB是Redis的默认持久化方式,默认存放路径是当前目录，文件名是:dump.rdb,RDB适合用于备份。
      例如，每小时归档最近24小时的RDB快照。这很容易的恢复不同版本的数据集以容灾,非常适合于灾难恢复。
      a,RDB持久化也分两种：SAVE和BGSAVE,默认是BGSAVE
          1,SAVE是阻塞式的RDB持久化，当执行这个命令时redis的主进程把内存里的数据库状态写入到RDB文件（即上面的dump.rdb）中，
          直到该文件创建完毕的这段时间内redis将不能处理任何命令请求。
          2,BGSAVE属于非阻塞式的持久化，它会创建一个子进程专门去把内存中的数据库状态写入RDB文件里，同时主进程还可以处理来自客户端的命令请求。
          但子进程基本是复制的父进程，这等于两个相同大小的redis进程在系统上运行，会造成内存使用率的大幅增加。
          比如说主进程8G内存，那么在备份的时候必须保证有16G内存，要不然会启用虚拟内存，性能非常差。
      b,如果数据集非常大并且 CPU 性能不够强大的话，fork()比较耗时,Redis 会停止服务客户端几毫秒甚至一秒。
      c,RDB文件过大时，是可以压缩的，Redis默认开启压缩，当然也可以通过配置rdbcompression参数来禁用压缩。
      d,手动快照:如果没有触发自动快照，可以对redis进行手动快照操作，SAVE和BGSAVE都可以执行手动快照，
          两个命令的区别是前者是由主进程进行快照操作，会阻塞其他请求；而后者是通过fork子进程进行快照操作。

      在redis.conf中的rdb配置
      dffilename  dump.rdb   ###rdb文件名
      dir  ./                ###rdb文件存放路径
      rdbcompression  yes    ###开启RDB文件压缩，默认开启压缩
      save 900 1             ###15分钟内至少有1个键被改动则进行快照
      save 300 10            ###5分钟内至少有10个键被改动则进行快照
      save 60  100           ###1分钟类至少有100个键被改动则进行快照，以上条件是"或"的关系
      在命令行中操作配置:
      > CONFIG GET save      ###查看redis持久化配置
      1) "save"
      2) "900 1 300 10 60 100"
      > CONFIG SET save "120 200"  ###修改redis持久化配置

-----------------------------------------------------
AOF---AOF持久化将发送到Redis服务端的每一条写命令都记录下来，并且保存到硬盘中的AOF文件中，类似打日志文件，来一条命令就记录一条。
      在服务器启动时，通过重新执行这些命令来还原数据集。
      a,AOF的持久化是通过命令追加、文件写入和文件同步三个步骤实现的。
          当reids开启AOF后，服务端每执行一次写操作（如set、sadd、rpush）就会把该条命令追加到一个单独的AOF缓冲区的末尾，这就是命令追加；
          然后把AOF缓冲区的内容写入AOF文件里。看上去第二步就已经完成AOF持久化了那第三步是干什么的呢?
          这就需要从系统的文件写入机制说起：一般现在所使用的操作系统，为了提高文件的写入效率，都会有一个写入策略，
          当往硬盘写入数据时，操作系统不是实时的将数据写入硬盘，而是先把数据暂时的保存在一个内存缓冲区里，
          等到这个内存缓冲区的空间被填满或者是超过了设定的时限后才会真正的把缓冲区内的数据写入硬盘中。
          也就是说当redis进行到第二步文件写入的时候，从用户的角度看是已经把AOF缓冲区里的数据写入到AOF文件了，
          但对系统而言只不过是把AOF缓冲区的内容放到了另一个内存缓冲区里而已，
          之后redis还需要进行文件同步把该内存缓冲区里的数据真正写入硬盘上才算是完成了一次持久化。
          而何时进行文件同步则是根据配置的appendfsync来进行： appendfsync有三个选项：always、everysec和no：
              1,选择always的时候服务器会在每执行一个事件就把AOF缓冲区的内容强制性的写入硬盘上的AOF文件里，
                  可以看成每执行一个redis写入命令就往AOF文件里记录这条命令，这保证了数据持久化的完整性，但效率是最慢的，却也是最安全的；
              2,配置成everysec的话服务端每执行一次写操作（如set、sadd、rpush）也会把该条命令追加到一个单独的AOF缓冲区的末尾，并将AOF缓冲区写入AOF文件，
                  然后每隔一秒才会进行一次文件同步把内存缓冲区里的AOF缓存数据真正写入AOF文件里，
                  这个模式兼顾了效率的同时也保证了数据的完整性，即使在服务器宕机也只会丢失一秒内对redis数据库做的修改；
              3,将appendfsync配置成no则意味redis数据库里的数据就算丢失也可以接受，它也会把每条写命令追加到AOF缓冲区的末尾，然后写入文件，
                  但什么时候进行文件同步真正把数据写入AOF文件里则由系统自身决定，即当内存缓冲区的空间被填满或者是超过了设定的时限后系统自动同步。
                  这种模式下效率是最快的，但对数据来说也是最不安全的，
                  如果redis里的数据都是从后台数据库如mysql中取出来的，属于随时可以找回或者不重要的数据，那么可以考虑设置成这种模式。
      b,AOF文件的位置和RDB文件的位置相同，都是通过dir参数设置，默认的文件名是appendonly.aof，可以通过appendfilename参数来修改。
      c,AOF文件重写可以去除数据的中间执行过程，直接保留最终数据命令。
        相比RDB每次持久化都会内存翻倍，AOF持久化除了在第一次启用时会新开一个子进程创建AOF文件会大幅度消耗内存外，之后的每次持久化对内存使用都很小。
        但AOF也有一个不可忽视的问题：AOF文件过大。对redis数据库的每一次写操作都会让AOF文件里增加一条数据，久而久之这个文件会很大。
        redis提出了AOF重写的机制，它创建一个精简化的AOF文件，里面去掉了多余的冗余命令，并对原AOF文件进行覆盖。
          如果不进行AOF重写的话，进行AOF文件恢复的时候，Redis会执行AOF文件中的每一条命令
          进行AOF重写后，相当于把中间的计算过程略去。直接把计算得到的结果设置进redis，相当于仅每个key执行了一条命令。
          使用BGREWRITEAOF命令来重写AOF文件。
          重写策略的参数设置:
          auto-aof-rewrite-percentage 100
          ###当前的AOF文件大小超过上一次重写后的AOF文件大小的百分之多少时，会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。
          auto-aof-rewrite-min-size 64mb
          ###限制了允许重写的最小AOF文件大小，通常在AOF文件很小的时候，即使其中有些冗余的命令也是可以忽略的。
      d,AOF Redis 会更具有可持久性(durable)：可以有很多不同的 fsync 策略：没有 fsync，每秒 fsync，每次请求时 fsync。
          使用默认的每秒 fsync 策略，写性能也仍然很不错(fsync 是由后台线程完成的，主线程继续努力地执行写请求)，只是宕机时有可能会损失一秒钟的写数据。
      e,AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。
          即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof 工具也可以很轻易的修复。
      f,AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。即使不小心错误地使用 FLUSHALL 命令清空一切，如果此时并没有执行重写，
          仍然可以恢复保存的数据集，只要停止服务器，删除AOF文件中的最后一条命令，然后重启 Redis 即可。
      在redis.conf中的aof配置
            appendonly yes                       ###开启AOF持久化，默认关闭
            dir  ./                              ###aop文件存放路径,其实跟rdb是一样的目录
            appendfilename "appendonly.aof"      ###AOF文件名称（默认）
            appendfsync everysec                 ###AOF持久化策略,有3种,always、everysec和no
            auto-aof-rewrite-percentage 100      ###触发AOF文件重写机制的重写的条件（默认）
            auto-aof-rewrite-min-size 64mb       ###触发AOF文件重写机制的重写的条件（默认）
            no-appendfsync-on-rewrite no         ###在AOF日志进行重写BGREWRITEAOF时，如果设置为yes表示新写操作不进行同步fsync，
                                                     只是暂存在缓冲区里，避免造成磁盘IO操作冲突，等重写完成后在写入。redis中默认为no
            aof-load-truncated yes               ###Redis再恢复时，忽略最后一条可能存在问题的指令(因为最后一条指令可能存在问题，比如写一半时突然断电了)
            aof-use-rdb-preamble no              ####Redis4.0新增RDB-AOF混合持久化格式，在开启了这个功能之后，AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，
                                                     其中RDB格式的内容用于记录已有的数据，而AOF格式的内存则用于记录最近发生了变化的数据，
                                                     这样Redis就可以同时兼有RDB持久化和AOF持久化的优点（既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据）。
------------------------------------
RDB与AOF对比
    a,RDB 在重启保存了大数据集的实例时比 AOF 要快。
    b,对同样的数据集，AOF 文件通常要大于等价的 RDB 文件。
Redis可以同时使用 AOF 持久化和 RDB 持久化。
通常来说，应该同时使用这两种持久化方法，以达到和 PostgreSQL 提供的一样的数据安全程度。

---------------------------------------------------------------------------------