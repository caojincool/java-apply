-----------------------------redis集群-------------------------
redis在3.0版本以后增加了集群特性，比以前的主从复制有了质的提升。
redis cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。
Redis集群中，节点负责存储数据、记录集群的状态（包括键值到正确节点的映射）。
集群节点同样能自动发现其他节点，检测出没正常工作的节点， 并且在需要的时候在从节点中推选出主节点。
一个主节点要被故障转移，必须是大多数主节点在至少 NODE_TIMEOUT 这么长时间里无法访问该节点。
其结构特点：
    1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
    2、节点的fail是通过集群中超过半数的节点检测失效时才生效。
    3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
    4、Redis集群没有使用一致性hash, 而是引入了哈希槽的概念。
       Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽
redis cluster节点分配
    三个主节点A, B, C,采用哈希槽 (hash slot)的方式来分配16384个slot，它们三个节点分别承担的slot 区间是：
    节点A覆盖0－5460;节点B覆盖5461－10922;节点C覆盖10923－16383.
    如果存入一个值，按照redis cluster哈希槽的算法： CRC16('key')%16384 = 6782。 那么就会把这个key 的存储分配到 B 上了。
    同样，当连接(A,B,C)任何一个节点想获取'key'这个key时，也会这样的算法，然后内部跳转到B节点上获取数据
    新增一个节点D，redis cluster从各个节点的前面各拿取一部分slot到D上，大致就会变成这样：
    节点A覆盖1365-5460,节点B覆盖6827-10922,节点C覆盖12288-16383,节点D覆盖0-1364,5461-6826,10923-12287
    同样删除一个节点也是类似，移动完成后就可以删除这个节点了。
redis cluster在线重新分片
    Redis 集群支持在集群运行过程中添加或移除节点。实际上，添加或移除节点都被抽象为同一个操作，那就是把哈希槽从一个节点移到另一个节点。
        向集群添加一个新节点，就是把一个空节点加入到集群中并把某些哈希槽从已存在的节点移到新节点上。
        从集群中移除一个节点，就是把该节点上的哈希槽移到其他已存在的节点上。所以实现这个的核心是能把哈希槽移来移去。
        从实际角度看，哈希槽就只是一堆键，所以 Redis 集群在重组碎片（reshard）时做的就是把键从一个节点移到另一个节点。
    Redis cluster的一些命令，用来操作 Redis 集群节点上的哈希槽转换表（slots translation table）
        CLUSTER ADDSLOTS slot1 [slot2] … [slotN]
        CLUSTER DELSLOTS slot1 [slot2] … [slotN]
        CLUSTER SETSLOT slot NODE node
        CLUSTER SETSLOT slot MIGRATING node
        CLUSTER SETSLOT slot IMPORTING node
    ADDSLOTS 和 DELSLOTS，就是简单地用来给一个 Redis 节点指派（assign）或移除哈希槽。

redis cluster高可用
    为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，
    当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。
    比如集群有A,B,C三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，就无法访问整个集群了。A和C的slot也无法访问。
    所以在集群建立的时候，一定要为每个主节点都添加了从节点,
    比如集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作。
    B1节点替代了B节点，Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点。
    如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了。
从节点的选举和提升
    一个从节点的选举是在它的主节点被至少一个具有成为主节点必备条件的从节点标记为 FAIL 的状态的时候发生的。
    当以下条件满足时，一个从节点可以发起选举：
        该从节点的主节点处于 FAIL 状态。
        这个主节点负责的哈希槽数目不为零。
        从节点和主节点之间的重复连接（replication link）断线不超过一段给定的时间，这是为了确保从节点的数据是可靠的。
    一个从节点想要被推选出来，那么第一步应该是提高它的 currentEpoch 计数，并且向集群中的所有主节点们请求投票。
    从节点通过广播一个 FAILOVER_AUTH_REQUEST 数据包给集群里的每个主节点来请求选票。然后等待回复（最多等 NODE_TIMEOUT 这么长时间）。
    一旦一个主节点给这个从节点投票，会回复一个 FAILOVER_AUTH_ACK，并且在 NODE_TIMEOUT * 2 这段时间内不能再给同个主节点的其他从节点投票。
    在这段时间内它完全不能回复其他授权请求。
    从节点会忽视所有带有的时期（epoch）参数比 currentEpoch 小的回应（ACKs），这样能避免把之前的投票的算为当前的合理投票。
    一旦某个从节点收到了大多数主节点的回应，那么它就赢得了选举。否则，如果无法在 NODE_TIMEOUT 时间内访问到大多数主节点，
    那么当前选举会被中断并在 NODE_TIMEOUT * 4 这段时间后由另一个从节点尝试发起选举。
    从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一点点延迟，这段延迟是这么计算的：
    DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +SLAVE_RANK * 1000 milliseconds.
    固定延时（fixed delay）确保我等到 FAIL 状态在集群内广播后，否则若从节点尝试发起选举，主节点们仍然不知道那个主节点已经 FAIL，就会拒绝投票。
    随机延时（random delay）是用来添加一些不确定因素以减少多个从节点在同一时间发起选举的可能性，
    因为若同时多个从节点发起选举或许会导致没有任何节点赢得选举，要再次发起另一个选举的话会使集群在当时变得不可用。
    一旦有从节点赢得选举，它就会开始用 ping 和 pong 数据包向其他节点宣布自己已经是主节点，并提供它负责的哈希槽，
    设置 configEpoch 为 currentEpoch（选举开始时生成的）。
    为了加速其他节点的重新配置，该节点会广播一个 pong 包 给集群里的所有节点（那些现在访问不到的节点最终也会收到一个 ping 包或 pong 包，并且进行重新配置）。
    其他节点会检测到有一个新的主节点（带着更大的configEpoch）在负责处理之前一个旧的主节点负责的哈希槽，然后就升级自己的配置信息。
备份迁移
    Redis 集群实现了一个叫做备份迁移（replica migration）的概念，以提高系统的可用性。
    例如有一个每个主节点都只有一个从节点的集群，当主节点或者从节点故障失效的时候集群能让操作继续执行下去，但如果主从节点都失效的话就没法让操作继续执行下去。
    主节点 A 有且只有一个从节点 A1。主节点 A 失效了。A1 被提升为新的主节点。之后，A1 因为一个独立事件（跟节点 A 的失效无关）失效了。
    由于没有其他从节点可以提升为主节点（因为节点 A 仍未恢复正常），集群没法继续进行正常操作。
    一个候选方案就是在集群中创建不对称性，然后让集群布局时不时地自动变化。
    例如，假设集群有三个主节点 A，B，C。节点 A 和 B 都各有一个从节点，A1 和 B1。节点 C 有两个从节点：C1 和 C2。
    备份迁移是从节点自动重构的过程，为了迁移到一个没有可工作从节点的主节点上。在上面提到的例子中，备份迁移过程如下：
        主节点 A 失效。A1 被提升为主节点。
        节点 C2 迁移成为节点 A1 的从节点，要不然 A1 就没有任何从节点。
        三个小时后节点 A1 也失效了。
        节点 C2 被提升为取代 A1 的新主节点。
        集群仍然能继续正常工作。
备份迁移算法
    迁移算法不用任何形式的协议，因为 Redis 集群中的从节点布局不是集群配置信息（配置信息要求前后一致并且/或者用 config epochs 来标记版本号）的一部分。
    它使用的是一个避免在主节点没有备份时从节点大批迁移的算法。这个算法保证，一旦集群配置信息稳定下来，最终每个主节点都至少会有一个从节点作为备份。
    一个好的从节点是指从给定节点的角度看，该从节点不处于 FAIL 状态。
    每个从节点若检测出存在至少一个没有好的从节点的单一主节点，那么就会触发这个算法的执行。然而在所有检测出这种情况的从节点中，只有一部分从节点会采取行动。
    通常这“一部分从节点”都只有一个，除非有不同的从节点在给定时间间隔里对其他节点的失效状态有稍微不同的视角。
    采取行动的从节点是属于那些拥有最多从节点的主节点，并且不处于 FAIL 状态及拥有最小的节点 ID。
    例如，如果有 10 个主节点，它们各有 1 个从节点，另外还有 2 个主节点，它们各有 5 个从节点。
    会尝试迁移的从节点是在那 2 个拥有 5 个从节点的主节点中的所有从节点里，节点 ID 最小的那个。
    已知不需要用到任何协议，在集群配置信息不稳定的情况下，有可能发生一种竞争情况：多个从节点都认为自己是不处于 FAIL 状态并且拥有较小节点 ID（实际上这是一种比较难出现的状况）。
    如果这种情况发生的话，结果是多个从节点都会迁移到同个主节点下，不过这种结局是无害的。
    这种竞争发生的话，有时候会使得割让出从节点的主节点变成没有任何备份节点，
    当集群再次达到稳定状态的时候，本算法会再次执行，然后把从节点迁移回它原来的主节点。
    最终每个主节点都会至少有一个从节点作为备份节点。
    这个算法能通过一个用户可配置的参数 cluster-migration-barrier 进行控制。
    这个参数表示的是，一个主节点在拥有多少个好的从节点的时候就要割让一个从节点出来。
    例如这个参数若被设为 2，那么只有当一个主节点拥有 2 个可工作的从节点时，它的一个从节点会尝试迁移。
redis cluster集群注意事项
    Redis集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.
    Redis集群不像单Redis那样支持多个数据库，集群只有数据库 0，而且也不支持SELECT命令
    Redis集群并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作.原因是因为集群是用了异步复制. 写操作过程:
        客户端向主节点B写入一条命令.
        主节点B向客户端回复命令状态.
        主节点将写操作复制给它的从节点 B1, B2 和 B3.
    主节点对命令的复制工作发生在返回命令回复之后。复制有可能在主节点出问题的时候而失败，而从节点还没来得及得到之前的命令就转换成主节点了，从而丢失上一条命令

---------------------------------------------------------------