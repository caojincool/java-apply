-------------------------------------mongodb复制集----------------------------------
mongodb复制集就是一组mongod实例掌管同一个数据集，实例可以在不同的机器上面。
实例中包含一个主库，接受客户端所有的写入操作，其他都是副本实例，从主库上获得数据并保持同步。
主服务器包含了所有的改变操作（写）的日志。副本服务器集群包含有所有的主服务器数据，
当主服务器挂掉了，就会在副本服务器上重新选取一个成为主服务器。
有的复制集还有一个仲裁者，仲裁者不存储数据，只是负责通过心跳包来确认集群中集合的数量，并在主服务器选举的时候作为仲裁决定结果。
当节点数目为奇数时，可以不需要仲裁节点。
当节点数目为偶数个时，需要部署一个仲裁节点，否则偶数个节点，当主节点挂了后，其他节点会变为只读。
mongodb复制集的基本架构:
a,三个存储数据的成员的复制集
      一个主库,两个从库组成，主库宕机时，这两个从库都可以被选为主库。
      当主库宕机后,两个从库都会进行竞选，其中一个变为主库，当原主库恢复后，作为从库加入当前的复制集群即可。
b,三个成员的复制集中,存在arbiter节点
      在三个成员的复制集中，一个主库,一个从库，可以在选举中成为主库，一个aribiter节点，在选举中，只进行投票，不能成为主库
mongodb复制集通过replSetInitiate命令（或mongo shell的rs.initiate()）进行初始化，
初始化后各个成员间开始发送心跳消息，并发起Priamry选举操作，
获得大多数成员投票支持的节点，会成为Primary，其余节点成为Secondary。

mongodb复制集中成员
Primary     主库,接受客户端所有的写入操作,包含了所有的改变操作（写）的日志。
Secondary   从库,参与Primary选举（自身也可能会被选为Primary），
            并从Primary同步最新写入的数据，以保证与Primary存储相同的数据。
Arbiter     Arbiter节点只参与投票，不能被选为Primary，并且不从Primary同步数据。
            比如部署了一个2个节点的复制集，1个Primary，1个Secondary，
            任意节点宕机，复制集将不能提供服务了（无法选出Primary），
            这时可以给复制集添加一个Arbiter节点，即使有节点宕机，仍能选出Primary。
            当复制集成员为偶数时，最好加入一个Arbiter节点，以提升复制集可用性。
Priority0   Priority0节点的选举优先级为0，不会被选举为Primary
            比如跨机房A、B部署了一个复制集，并且想指定Primary必须在A机房，
            这时可以将B机房的复制集成员Priority设置为0，这样Primary就一定会是A机房的成员。
            最好将大多数节点部署在A机房，否则网络分区时可能无法选出Primary
Vote0       Mongodb 3.0里，复制集成员最多50个，参与Primary选举投票的成员最多7个，
            其他成员（Vote0）的vote属性必须设置为0，即不参与投票。
Hidden      隐藏节点,Hidden节点不能被选为主（Priority为0），客户端将不会把读请求分发到隐藏节点上，即使设定了复制集读选项 。
            因隐藏节点将不会收到来自应用程序的请求，可使用Hidden节点做一些数据备份、离线计算的任务，不会影响复制集的服务。
Delayed     延时节点,延时节点的数据集是延时的,Delayed节点必须是Hidden节点，并且其数据落后与Primary一段时间（可配置，比如1个小时）。
            因Delayed节点的数据比Primary落后一段时间，当错误或者无效的数据写入Primary时，可通过Delayed节点的数据来恢复到之前的时间点。
mongodb默认是由主节点读写数据的，副本节点上不允许读，需要设置slaveOk=true使副本节点可以读。
在交互命令行执行db.getMongo().setSlaveOk()或rs.slaveOk()也能使节点可读,但是下次再通过mongo进入实例的时候，查询仍会报错
如果是通过java访问secondary的则会报下面的异常com.mongodb.MongoException: not talking to master and retries used up
解决办法如下:
第1种方法-->在java代码中调用dbFactory.getDb().slaveOk();
第2种方法-->在java代码中调用
    dbFactory.getDb().setReadPreference(ReadPreference.secondaryPreferred());//在复制集中优先读secondary，如果secondary访问不了的时候就从master中读
    或
    dbFactory.getDb().setReadPreference(ReadPreference.secondary());//只从secondary中读，如果secondary访问不了的时候就不能进行查询
第3种方法：在配置mongo的时候增加slave-ok="true"也支持直接从secondary中读
<mongo:mongo id="mongo" host="${mongodb.host}" port="${mongodb.port}">
        <mongo:options slave-ok="true"/>
</mongo:mongo>


------------------------------------------------------------------------------------