-----------------------------mysl索引b-tree,hah,full-text,r-tree-------------------------
mysql里目前只支持4种索引分别是:b-tree,full-text,hash以及r-tree索引
mysql中主键索引是聚集（clustered）索引，也叫聚簇索引。
聚集索引是数据行的物理顺序与索引列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。聚集索引引用的也是B+树索引。
聚集索引的叶子节点就是对应的数据节点（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，
而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询。因此在查询方面，聚集索引的速度往往会更占优势。

非聚集（unclustered）索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。
如果使用非聚集索引查询，而查询列中包含了该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。
非聚集索引叶子节点除了会存储索引覆盖列的数据，也会存放聚集索引所覆盖的列数据。
解决非聚集索引的二次查询问题就是创建复合索引(覆盖索引),即可查询复合索引里的列的数据而不需要进行回表二次查询

比如表t1永远主键索引id,以及普通索引username,
select id,username from t1 where id = 1                          ###使用主键索引直接一次性查出结果
select id,username from t1 where username = 'aa'                 ###使用普通索引username直接查出结果,不需要回表查询,非聚集索引也会存放聚集索引所覆盖的列数据。
select username from t1 where username = 'aa'                    ###使用普通索引username直接查出结果,不需要回表查询
select username,score from t1 where username = 'aa'              ###使用普通索引username查询，需要回表查询

--------------b-tree------------
b-tree索引应该是mysql里最广泛的索引的了,除了archive,基本所有的存储引擎都支持它.

1.b-tree在myisam里的形式和innodb稍有不同

在innodb里面有两种形态:
其一是primary key形态其leafnode里存放的是数据.而且不仅存放了索引键的数据,还包括事务ID和回滚指针(rollback pointer)——用于事务和MVCC，和余下的所有表列。
其二是secondary index,其leafnode和普通的b-tree差不多,只是还存放了指向主键的信息。

而在myisam里,主键和其他的并没有太大区别.它不支持聚簇索引,Primary key仅仅只是一个叫做PRIMARY的唯一，非空的索引而已。叶子节点按照主键的顺序存储。
不过和innodb不太一样的地方是,在myisam里,leaf node里存放的不是主键的信息,存的是指向数据文件里的对应数据行的信息,仅包含行号(row number),也就是行指针。

覆盖索引(Covering Indexes)是索引包含满足查询的所有数据就被称为覆盖索引，它的叶子节点中已经包含要查询的数据，那么就没有必要再回表查询。
如果查询采用的索引是覆盖索引，使用EXPLAIN时，可以在Extra一列中看到“Using index”。

--------------hash--------------
2.hash索引,目前我所知道的就只有memory和ndb cluster支持这种索引.

hash索引由于其结构,所以在每次查询的时候直接一次到位不行b-tree那样,一点点的前进,所以hash索引的效率高于b-tree.但hash也有缺点,主要如下:

(1)由于存放的是hash值,所以仅支持<=>以及in操作.

(2)hash索引无法通过操作索引来排序,这是因为存放的时候经过hash计算,但是计算的hash值和存放的不一定相等,所以无法排序.

(3)在组合所以里,无法对部分使用索引.

(4)不能避免全表扫描,只是由于在memory表里支持非唯一值hash索引,就是不同的索引键,可能存在相同的hash值.

(5)当存在大量相同hash值得时候,hash索引的效率会变低.
------------full-text-----------

3.full-text索引

full-text在mysql里仅有myisam支持它,而且支持full-text的字段只有char,varchar,以及text数据类型,full-text主要是用来代替like "%***%"效率低下的问题的.
------------r-tree-------------
4.r-tree索引

r-tree在mysql很少使用,仅支持geometry数据类型,支持该类型的存储引擎只有myisam,bdb,innodb,ndb,archive几种.相对于b-tree,r-tree的优势在于范围查找.

----------------------------------------------------------------------------------

二 mysql里sql语句值得注意的地方

1.myisam里所以键的长度仅支持1000字节,innodb是767.

2.blob和text字段仅支持前缀索引.

3.使用!=以及<>不等于的时候mysql不使用索引.

4.当在字段使用函数的时候,mysql无法使用索引,在join的时候条件字段类型不一致的时候,mysql无法使用索引,在组合索引里使用非第一个索引时也不使用索引.

5.在使用like的时候,以%开头,即"%***"的时候无法使用索引,在使用or的时候,要求or前后字段都有索引.

有时候mysql query optimizer会认为使用索引并不是最优计划,所以不使用索引,可以在sql语句里可以用 force index,当然有时候使用也不会比不用快,所以需要忽略掉index方法是ignore index.

关闭查询缓存sql_no_cache

select sql_no_cache * from table_name;

这样可以让一些很少使用的语句不放在缓存里,查找的时候不会去缓存里找.对应的是强制缓存sql_cache

select sql_cache * from table_name;

另外在my.cnf中如果设置query_cache_type=2的话,那么只有在使用sql_cache后才会使用缓存;

还有mysql里的优先操作hight_priority让mysql优先操作这个语句

select high_priority * fromtable_name;

与其对应的是low_priority;

mysql里还有延时插入insert delayed

insert delayed into table_name....;#当提交之后,mysql返回ok,但不立即插入,二十当mysql有空再插入.假如等待时服务器崩溃,那么所有数据丢失!并且插入不会返回自增id.

再转几个技巧:

强制连接顺序 STRAIGHT_JOIN

SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE …

由上面的SQL语句可知，通过STRAIGHT_JOIN强迫MySQL按TABLE1、TABLE2的顺序连接表。如果你认为按自己的顺序比MySQL推荐的顺序进行连接的效率高的话，就可以通过STRAIGHT_JOIN来确定连接顺序。

强制使用临时表 SQL_BUFFER_RESULT

SELECT SQL_BUFFER_RESULT * FROM TABLE1 WHERE …

当我们查询的结果集中的数据比较多时，可以通过SQL_BUFFER_RESULT.选项强制将结果集放到临时表中，这样就可以很快地释放MySQL的表锁（这样其它的SQL语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集。

分组使用临时表 SQL_BIG_RESULT和SQL_SMALL_RESULT

SELECT SQL_BUFFER_RESULT FIELD1, COUNT(*) FROM TABLE1 GROUP BY FIELD1;

一般用于分组或DISTINCT关键字，这个选项通知MySQL，如果有必要，就将查询结果放到临时表中，甚至在临时表中进行排序。SQL_SMALL_RESULT比起SQL_BIG_RESULT差不多，很少使用。

--------------------------------------------------