----------------------------------mysql多版本并发控制-------------------------------
mysql多版本并发控制就是在表数据每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。
mvcc使得数据库读不会对数据加锁，select不会加锁，提高了数据库的并发处理能力；
mysql的innodb采用的是行锁，而且采用了多版本并发控制来提高读操作的性能。
只有read-committed和repeatable-read两种事务隔离级别才能使用mVcc,read-uncommited由于是读到未提交的，不存在版本的问题,serializable则会对所有读取的行加锁。

1、在插入操作时,记录的创建版本号就是事务版本号。
insert aa(id,name) values(1,'test');
.......................................................
|id 	|name 	   |create version 	   |delete version|
.......................................................
|1 	    |test 	   |1                  |              |
.......................................................

2、在更新操作时，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。
update aa set name= 'bbbb' where id=1;
.......................................................
|id 	|name 	   |create version 	   |delete version|
.......................................................
|1 	    |test 	   |1                  |2             |
.......................................................
|1 	    |bbbb 	   |2                  |              |
.......................................................

3、在删除操作时，就把事务版本号作为删除版本号。比如
delete from aa where id=1;
.......................................................
|id 	|name 	   |create version 	   |delete version|
.......................................................
|1 	    |bbbb 	   |2                  |3             |
.......................................................

4、查询操作：
读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。
从这里也可以体会到一种提高系统性能的思路，通过版本号来减少锁的争用。

快照读和当前读
快照读--->读取的是快照版本，也就是历史版本
当前读--->读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT …  LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读

锁定读
在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE。
SELECT ... LOCK IN SHARE MODE,给记录假设共享锁，其它事务只能读不能修改，直到当前事务提交
SELECT ... FOR UPDATE,给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的

一致性非锁定读
consistent read （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。
如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；
如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。
Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。
一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。

悲观锁和乐观锁
悲观锁，数据库总是认为别人会去修改它所要操作的数据，因此在数据库处理过程中将数据加锁。其实现依靠数据库底层。
乐观锁，总是认为别人不会去修改，只有在提交更新的时候去检查数据的状态。通常是给数据增加一个字段来标识数据的版本。

----------------------------------------------------------------------------------